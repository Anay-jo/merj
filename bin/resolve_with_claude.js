#!/usr/bin/env node
// Enhanced tool: describe the merge conflict AND produce a merged file suggestion
// Usage:
//   node bin/resolve_with_claude.js               # auto-pick first conflicted file
//   node bin/resolve_with_claude.js --file path   # specify a file
// Env:
//   ANTHROPIC_API_KEY (or ANTHROPIC)
//   MODEL (optional, defaults to 'claude-3-5-sonnet-20241022' or 'claude-sonnet-4-5')

const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const API_KEY = process.env.ANTHROPIC_API_KEY || process.env.ANTHROPIC;
const MODEL = 'claude-sonnet-4-5';

function assertInGitRepo() {
  const r = spawnSync('git', ['rev-parse', '--show-toplevel'], { encoding: 'utf-8' });
  if (r.status !== 0) {
    console.error('‚ùå Not a git repository. Run inside a repo with .git present.');
    process.exit(1);
  }
  return r.stdout.trim();
}

function listConflictedFiles(cwd) {
  const r = spawnSync('git', ['ls-files', '-u'], { cwd, encoding: 'utf-8' });
  if (r.status !== 0) return [];
  const lines = r.stdout.trim().split('\n').filter(Boolean);
  const files = new Set();
  for (const ln of lines) {
    const parts = ln.trim().split(/\s+/);
    const file = parts[3];
    if (file) files.add(file);
  }
  return [...files];
}

function read(p) {
  try { return fs.readFileSync(p, 'utf-8'); } catch { return null; }
}

function loadRAGContext() {
  // Try to load RAG context generated by the pipeline
  const ragContextPath = path.join(process.cwd(), 'rag_output', 'llm_context.txt');
  try {
    if (fs.existsSync(ragContextPath)) {
      const content = fs.readFileSync(ragContextPath, 'utf-8');
      const sizeKB = (content.length / 1024).toFixed(1);
      const lines = content.split('\n').length;
      console.log('üìö Loaded RAG context from:', ragContextPath);
      console.log(`   Size: ${sizeKB}KB, Lines: ${lines}`);

      // Show a preview of the context
      const preview = content.substring(0, 200).replace(/\n/g, ' ');
      console.log(`   Preview: ${preview}${content.length > 200 ? '...' : ''}`);

      // Format RAG context for appending with CodeRabbit context
      let formattedContext = [];
      
      // Add header for RAG context
      formattedContext.push('=== RAG CODE CHUNKS CONTEXT ===');
      formattedContext.push('(Similar code patterns and chunks for merge conflict resolution)');
      formattedContext.push('');
      
      // Add the original RAG content
      formattedContext.push(content);
      
      // Add clear separator for appending with CodeRabbit context
      formattedContext.push('');
      formattedContext.push('=== END RAG CONTEXT ===');
      formattedContext.push('');

      const formatted = formattedContext.join('\n');
      console.log(`   RAG context formatted for CodeRabbit appending`);

      return formatted;
    } else {
      console.log('‚ö†Ô∏è  RAG context file not found at:', ragContextPath);
      console.log('   Run "merj pull" first to generate RAG context');
    }
  } catch (e) {
    console.log('‚ùå Error loading RAG context:', e.message);
  }
  return null;
}

function loadCodeRabbitContext() {
  // Try to load CodeRabbit findings
  const codeRabbitPath = path.join(process.cwd(), 'rag_output', 'coderabbit_review.json');
  try {
    if (fs.existsSync(codeRabbitPath)) {
      const content = fs.readFileSync(codeRabbitPath, 'utf-8');
      const data = JSON.parse(content);

      console.log('üê∞ Loaded CodeRabbit findings from:', codeRabbitPath);

      // Format the findings into readable text optimized for appending with RAG chunks
      let formattedContext = [];
      
      // Add header for semantic context
      formattedContext.push('=== CODERABBIT SEMANTIC CONTEXT ===');
      formattedContext.push('(Automated code review findings for merge conflict resolution)');
      formattedContext.push('');

      // Process main branch review
      if (data.mainBranchReview) {
        formattedContext.push('## Main Branch Changes (Remote/Incoming):');
        const findings = extractFindings(data.mainBranchReview);
        if (findings.length > 0) {
          findings.forEach((f, i) => {
            formattedContext.push(`${i+1}. ${f.file}:${f.line} - ${f.message}`);
          });
        } else {
          formattedContext.push('(No issues found in main branch changes)');
        }
        formattedContext.push('');
      }

      // Process local branch review
      if (data.localBranchReview) {
        formattedContext.push('## Local Branch Changes (Your Branch):');
        const findings = extractFindings(data.localBranchReview);
        if (findings.length > 0) {
          findings.forEach((f, i) => {
            formattedContext.push(`${i+1}. ${f.file}:${f.line} - ${f.message}`);
          });
        } else {
          formattedContext.push('(No issues found in local branch changes)');
        }
        formattedContext.push('');
      }

      // Add summary for LLM context
      const totalFindings = (data.mainBranchReview ? extractFindings(data.mainBranchReview).length : 0) + 
                           (data.localBranchReview ? extractFindings(data.localBranchReview).length : 0);
      
      if (totalFindings > 0) {
        formattedContext.push('## CodeRabbit Summary:');
        formattedContext.push(`- Total findings: ${totalFindings}`);
        formattedContext.push('- Review these findings when resolving merge conflicts');
        formattedContext.push('- Consider addressing any security, performance, or style issues');
        formattedContext.push('');
      }

      // Add clear separator for appending with RAG context
      formattedContext.push('=== END CODERABBIT CONTEXT ===');
      formattedContext.push('');

      const formatted = formattedContext.join('\n');
      console.log(`   Found ${totalFindings} total CodeRabbit findings`);
      console.log(`   Context formatted for RAG chunk appending`);

      return formatted;
    } else {
      console.log('‚ö†Ô∏è  CodeRabbit findings not found at:', codeRabbitPath);
      console.log('   Run "merj pull" first to generate CodeRabbit analysis');
    }
  } catch (e) {
    console.log('‚ùå Error loading CodeRabbit findings:', e.message);
  }
  return null;
}

function extractFindings(data) {
  // Extract findings from various possible CodeRabbit output formats
  if (!data) return [];

  const findings = [];

  // Handle different shapes of CodeRabbit output
  const sources = Array.isArray(data) ? data
                : Array.isArray(data?.issues) ? data.issues
                : Array.isArray(data?.comments) ? data.comments
                : [];

  sources.forEach(f => {
    findings.push({
      file: f.file || f.path || f.filename || 'unknown',
      line: f.line || f.start_line || f.position || '?',
      message: f.message || f.body || f.summary || JSON.stringify(f).slice(0, 200)
    });
  });

  return findings;
}

function buildDescriptionPrompt({ filePath, conflictedCode, ragContext, codeRabbitContext }) {
  const system = [
    'You are a senior software engineer and merge specialist.',
    'Task: Describe the merge conflict found in the provided file. Do not attempt to rewrite or resolve it; only analyze and explain.',
    'Explain clearly for a developer who will resolve it manually.',
    ragContext ? 'You have been provided with RAG context showing what each branch was changing.' : '',
    codeRabbitContext ? 'You have been provided with CodeRabbit code review findings.' : ''
  ].filter(Boolean).join(' ');

  const userParts = [];

  // Add CodeRabbit findings if available
  if (codeRabbitContext) {
    userParts.push(
      '# CodeRabbit Code Review Findings',
      '(These are automated code review findings for both branches)',
      '',
      codeRabbitContext,
      '',
      '---',
      ''
    );
  }

  // Add RAG context if available
  if (ragContext) {
    userParts.push(
      '# Code Context from RAG Pipeline',
      '(This shows what code was being modified around the conflict areas)',
      '',
      ragContext,
      '',
      '---',
      ''
    );
  }

  // Add combined context section (Step 3: Append RAG chunks to CodeRabbit semantic context)
  if (codeRabbitContext && ragContext) {
    userParts.push(
      '# Combined Context (CodeRabbit + RAG)',
      '(This combines automated code review findings with similar code patterns)',
      '',
      codeRabbitContext,
      '',
      '--- RAG Context ---',
      '',
      ragContext,
      '',
      '--- End Combined Context ---',
      ''
    );
  }

  userParts.push(
    '# File path',
    filePath,
    '',
    '# Instructions',
    '- Summarize where the conflict blocks occur.',
    '- For each conflict block, explain differences between OURS/HEAD (upper) and THEIRS/INCOMING (lower).',
    '- Note overlapping edits, removed/added functions, and any risky changes (e.g., API shape, return types, side effects).',
    '- Suggest a safe merge strategy at a high level (keep ours, keep theirs, or combine ‚Äì and why).',
    ragContext ? '- Use the RAG context to understand what each branch was trying to achieve.' : '',
    codeRabbitContext ? '- Consider the CodeRabbit findings when assessing code quality and potential issues.' : '',
    (codeRabbitContext && ragContext) ? '- Use the combined context to make informed decisions about code quality and patterns.' : '',
    '',
    '# Conflicted file with markers',
    '```',
    conflictedCode,
    '```'
  );

  const user = userParts.filter(Boolean).join('\n');

  return { system, messages: [{ role: 'user', content: user }] };
}

function buildResolutionPrompt({ filePath, conflictedCode, ragContext, codeRabbitContext }) {
  const system = [
    'You are an expert merge tool, who can only output code. Do not indicate lines by saying line1:, line2:, etc.',
    'Task: Resolve the merge conflict intelligently and return the final merged file, as just code, with no line indicators, or plain english anywhere.',
    'STRICT OUTPUT: Output ONLY the resolved code with all conflict markers removed. Do not include explanations, comments, markdown fences, or any english anywhere',
    'Preserve formatting and non-conflicted lines exactly as in the original file.',
    'Merge both sides when possible; if mutually exclusive, prefer safe combination rather than deletion.',
    ragContext ? 'Use the provided RAG context to understand the intent behind each change and make an informed merge decision.' : '',
    codeRabbitContext ? 'Consider CodeRabbit findings to avoid introducing issues found in either branch.' : ''
  ].filter(Boolean).join(' ');

  const userParts = [];

  // Add CodeRabbit findings if available
  if (codeRabbitContext) {
    userParts.push(
      '# CodeRabbit Code Review Findings',
      '(These are automated code review findings for both branches)',
      '',
      codeRabbitContext,
      '',
      '---',
      ''
    );
  }

  // Add RAG context if available
  if (ragContext) {
    userParts.push(
      '# Code Context from RAG Pipeline',
      '(This shows what code was being modified around the conflict areas)',
      '',
      ragContext,
      '',
      '---',
      ''
    );
  }

  // Add combined context section (Step 3: Append RAG chunks to CodeRabbit semantic context)
  if (codeRabbitContext && ragContext) {
    userParts.push(
      '# Combined Context (CodeRabbit + RAG)',
      '(This combines automated code review findings with similar code patterns)',
      '',
      codeRabbitContext,
      '',
      '--- RAG Context ---',
      '',
      ragContext,
      '',
      '--- End Combined Context ---',
      ''
    );
  }

  userParts.push(
    '# File path',
    filePath,
    '',
    '# Conflicted file',
    '```',
    conflictedCode,
    '```'
  );

  const user = userParts.join('\n');

  return { system, messages: [{ role: 'user', content: user }] };
}

async function callClaude({ model, system, messages }) {
  if (!API_KEY) {
    console.error('‚ùå Missing ANTHROPIC_API_KEY (or ANTHROPIC) in environment.');
    process.exit(1);
  }
  const res = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
      'x-api-key': API_KEY,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({ model, max_tokens: 2000, temperature: 0.2, system, messages })
  });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    console.error(`‚ùå Claude API error ${res.status}: ${text}`);
    process.exit(1);
  }
  const data = await res.json();
  const contentBlocks = data.content || [];
  const firstText = contentBlocks.map(b => b.text).filter(Boolean).join('\n');
  return firstText || '';
}

(async function main() {
  const repoRoot = assertInGitRepo();
  const argv = process.argv.slice(2);
  let fileFlag = null;
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if ((a === '--file' || a === '-f') && argv[i+1]) { fileFlag = argv[++i]; }
    else if (a === '--help' || a === '-h') {
      console.log('Usage: resolve_with_claude [--file <path>]');
      process.exit(0);
    }
  }

  let targetFile = fileFlag;
  const conflicted = listConflictedFiles(repoRoot);
  if (!targetFile) {
    if (conflicted.length === 0) {
      console.error('‚ùå No conflicted files detected. Pass --file <path> to analyze a specific file.');
      process.exit(1);
    }
    targetFile = conflicted[0];
  }

  const absFile = path.join(repoRoot, targetFile);
  if (!fs.existsSync(absFile)) {
    console.error(`‚ùå File not found: ${targetFile}`);
    process.exit(1);
  }

  const conflictedCode = read(absFile);
  if (!conflictedCode || !conflictedCode.includes('<<<<<<<')) {
    console.error('‚ùå The selected file does not contain Git conflict markers.');
    process.exit(1);
  }

  // Load RAG context if available
  const ragContext = loadRAGContext();

  // Load CodeRabbit findings if available
  const codeRabbitContext = loadCodeRabbitContext();

  // Step 6: Verify Output - Check that both contexts are loaded and will be passed to LLM
  console.log('\nüîç Step 6: Verifying Output...');
  console.log('==========================================');
  
  if (ragContext) {
    console.log('‚úÖ RAG Context: Loaded successfully');
    const ragLines = ragContext.split('\n').length;
    console.log(`   Size: ${ragLines} lines`);
    if (ragContext.includes('=== RAG CODE CHUNKS CONTEXT ===')) {
      console.log('‚úÖ RAG Context: Properly formatted with headers');
    } else {
      console.log('‚ö†Ô∏è  RAG Context: Missing expected headers');
    }
  } else {
    console.log('‚ö†Ô∏è  RAG Context: Not loaded');
  }
  
  if (codeRabbitContext) {
    console.log('‚úÖ CodeRabbit Context: Loaded successfully');
    const crLines = codeRabbitContext.split('\n').length;
    console.log(`   Size: ${crLines} lines`);
    if (codeRabbitContext.includes('=== CODERABBIT SEMANTIC CONTEXT ===')) {
      console.log('‚úÖ CodeRabbit Context: Properly formatted with headers');
    } else {
      console.log('‚ö†Ô∏è  CodeRabbit Context: Missing expected headers');
    }
  } else {
    console.log('‚ö†Ô∏è  CodeRabbit Context: Not loaded');
  }
  
  if (ragContext && codeRabbitContext) {
    console.log('‚úÖ Combined Context: Both contexts available for appending');
  } else {
    console.log('‚ö†Ô∏è  Combined Context: Missing one or both contexts');
  }
  
  console.log('==========================================');
  console.log('');

  // Step 1: Describe the conflict
  const describePrompt = buildDescriptionPrompt({
    filePath: targetFile,
    conflictedCode,
    ragContext,
    codeRabbitContext
  });
  
  // Step 6: Verify that prompts contain expected content
  console.log('üîç Verifying Description Prompt...');
  const descriptionPromptText = describePrompt.messages[0].content;
  
  if (descriptionPromptText.includes('Combined Context (CodeRabbit + RAG)')) {
    console.log('‚úÖ Description Prompt: Contains Combined Context section');
  } else {
    console.log('‚ö†Ô∏è  Description Prompt: Missing Combined Context section');
  }
  
  if (descriptionPromptText.includes('CodeRabbit')) {
    console.log('‚úÖ Description Prompt: Contains CodeRabbit context');
  } else {
    console.log('‚ö†Ô∏è  Description Prompt: Missing CodeRabbit context');
  }
  
  if (descriptionPromptText.includes('RAG')) {
    console.log('‚úÖ Description Prompt: Contains RAG context');
  } else {
    console.log('‚ö†Ô∏è  Description Prompt: Missing RAG context');
  }
  
  console.log(`   Total prompt size: ${descriptionPromptText.length} characters`);
  console.log('');
  
  const description = await callClaude({ model: MODEL, system: describePrompt.system, messages: describePrompt.messages });

  console.log('\nClaude Analysis:\n');
  console.log(description.trim());

  // Step 2: Ask Claude to produce the merged file
  const resolvePrompt = buildResolutionPrompt({
    filePath: targetFile,
    conflictedCode,
    ragContext,
    codeRabbitContext
  });
  
  // Step 6: Verify Resolution Prompt
  console.log('\nüîç Verifying Resolution Prompt...');
  const resolutionPromptText = resolvePrompt.messages[0].content;
  
  if (resolutionPromptText.includes('Combined Context (CodeRabbit + RAG)')) {
    console.log('‚úÖ Resolution Prompt: Contains Combined Context section');
  } else {
    console.log('‚ö†Ô∏è  Resolution Prompt: Missing Combined Context section');
  }
  
  if (resolutionPromptText.includes('CodeRabbit')) {
    console.log('‚úÖ Resolution Prompt: Contains CodeRabbit context');
  } else {
    console.log('‚ö†Ô∏è  Resolution Prompt: Missing CodeRabbit context');
  }
  
  if (resolutionPromptText.includes('RAG')) {
    console.log('‚úÖ Resolution Prompt: Contains RAG context');
  } else {
    console.log('‚ö†Ô∏è  Resolution Prompt: Missing RAG context');
  }
  
  console.log(`   Total prompt size: ${resolutionPromptText.length} characters`);
  console.log('');
  
  const resolved = await callClaude({ model: MODEL, system: resolvePrompt.system, messages: resolvePrompt.messages });

  // Clean up the resolved code - remove markdown code fences if present
  let cleanedCode = String(resolved).trim();
  
  // Remove markdown code fences (```python, ```javascript, etc.)
  cleanedCode = cleanedCode.replace(/^```[\w]*\n?/gm, '');  // Remove opening fence
  cleanedCode = cleanedCode.replace(/\n?```\s*$/gm, '');    // Remove closing fence
  cleanedCode = cleanedCode.trim();
  
  // Save merged file output as a separate copy; do NOT modify original
const OUTPUT_ROOT = process.env.MERGE_OUTPUT_ROOT || '/tmp/merged_suggestions';
const outPath = path.join(OUTPUT_ROOT, path.relative(repoRoot, absFile));
fs.mkdirSync(path.dirname(outPath), { recursive: true });
const resolvedCode = cleanedCode + '\n';
fs.writeFileSync(outPath, resolvedCode, 'utf-8');
console.log(`\n‚úÖ Wrote merged suggestion to: ${outPath}\n`);
// Print the merged file contents to STDOUT
process.stdout.write(resolvedCode);
})();

